# 界面设计 - 响应式设计

## 1. 响应式设计概述

### 1.1 设计目标
- **多设备适配**：支持桌面、平板、手机等各种设备
- **一致体验**：在不同设备上保持功能和体验的一致性
- **性能优化**：针对不同设备优化加载和渲染性能
- **触摸友好**：为触摸设备提供良好的交互体验
- **可访问性**：确保在各种设备上的可访问性

### 1.2 响应式策略
```
响应式设计策略
├── 断点系统 (Breakpoint System)
│   ├── 移动端优先 (Mobile First)
│   ├── 渐进增强 (Progressive Enhancement)
│   └── 灵活断点 (Flexible Breakpoints)
├── 布局适配 (Layout Adaptation)
│   ├── 流式布局 (Fluid Layout)
│   ├── 弹性网格 (Flexible Grid)
│   └── 组件重排 (Component Reflow)
├── 内容策略 (Content Strategy)
│   ├── 内容优先级 (Content Priority)
│   ├── 渐进式显示 (Progressive Disclosure)
│   └── 自适应内容 (Adaptive Content)
└── 交互适配 (Interaction Adaptation)
    ├── 触摸优化 (Touch Optimization)
    ├── 手势支持 (Gesture Support)
    └── 输入适配 (Input Adaptation)
```

## 2. 断点系统设计

### 2.1 断点定义
```scss
// styles/breakpoints.scss

// 断点变量定义
$breakpoints: (
  'xs': 0px,        // 超小屏幕 (手机竖屏)
  'sm': 576px,      // 小屏幕 (手机横屏)
  'md': 768px,      // 中等屏幕 (平板竖屏)
  'lg': 1024px,     // 大屏幕 (平板横屏/小桌面)
  'xl': 1200px,     // 超大屏幕 (桌面)
  'xxl': 1600px     // 超超大屏幕 (大桌面)
);

// 容器最大宽度
$container-max-widths: (
  'sm': 540px,
  'md': 720px,
  'lg': 960px,
  'xl': 1140px,
  'xxl': 1320px
);

// 媒体查询混合器
@mixin media-up($breakpoint) {
  @if map-has-key($breakpoints, $breakpoint) {
    $min-width: map-get($breakpoints, $breakpoint);
    @if $min-width != 0 {
      @media (min-width: $min-width) {
        @content;
      }
    } @else {
      @content;
    }
  }
}

@mixin media-down($breakpoint) {
  @if map-has-key($breakpoints, $breakpoint) {
    $max-width: map-get($breakpoints, $breakpoint) - 1px;
    @media (max-width: $max-width) {
      @content;
    }
  }
}

@mixin media-between($lower, $upper) {
  @if map-has-key($breakpoints, $lower) and map-has-key($breakpoints, $upper) {
    $min-width: map-get($breakpoints, $lower);
    $max-width: map-get($breakpoints, $upper) - 1px;
    
    @if $min-width != 0 {
      @media (min-width: $min-width) and (max-width: $max-width) {
        @content;
      }
    } @else {
      @media (max-width: $max-width) {
        @content;
      }
    }
  }
}

@mixin media-only($breakpoint) {
  @if $breakpoint == 'xs' {
    @include media-down('sm') {
      @content;
    }
  } @else if $breakpoint == 'sm' {
    @include media-between('sm', 'md') {
      @content;
    }
  } @else if $breakpoint == 'md' {
    @include media-between('md', 'lg') {
      @content;
    }
  } @else if $breakpoint == 'lg' {
    @include media-between('lg', 'xl') {
      @content;
    }
  } @else if $breakpoint == 'xl' {
    @include media-between('xl', 'xxl') {
      @content;
    }
  } @else if $breakpoint == 'xxl' {
    @include media-up('xxl') {
      @content;
    }
  }
}
```

### 2.2 JavaScript断点检测
```javascript
// utils/breakpoints.js

export const BREAKPOINTS = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 1024,
  xl: 1200,
  xxl: 1600
}

export const BREAKPOINT_NAMES = Object.keys(BREAKPOINTS)

/**
 * 获取当前断点
 */
export function getCurrentBreakpoint() {
  const width = window.innerWidth
  
  for (let i = BREAKPOINT_NAMES.length - 1; i >= 0; i--) {
    const breakpointName = BREAKPOINT_NAMES[i]
    const breakpointValue = BREAKPOINTS[breakpointName]
    
    if (width >= breakpointValue) {
      return breakpointName
    }
  }
  
  return 'xs'
}

/**
 * 检查是否为移动设备
 */
export function isMobile() {
  return window.innerWidth < BREAKPOINTS.md
}

/**
 * 检查是否为平板设备
 */
export function isTablet() {
  return window.innerWidth >= BREAKPOINTS.md && window.innerWidth < BREAKPOINTS.lg
}

/**
 * 检查是否为桌面设备
 */
export function isDesktop() {
  return window.innerWidth >= BREAKPOINTS.lg
}

/**
 * 断点变化监听器
 */
export class BreakpointWatcher {
  constructor() {
    this.listeners = []
    this.currentBreakpoint = getCurrentBreakpoint()
    
    this.handleResize = this.handleResize.bind(this)
    window.addEventListener('resize', this.handleResize)
  }
  
  handleResize() {
    const newBreakpoint = getCurrentBreakpoint()
    
    if (newBreakpoint !== this.currentBreakpoint) {
      const oldBreakpoint = this.currentBreakpoint
      this.currentBreakpoint = newBreakpoint
      
      this.listeners.forEach(listener => {
        listener(newBreakpoint, oldBreakpoint)
      })
    }
  }
  
  addListener(callback) {
    this.listeners.push(callback)
  }
  
  removeListener(callback) {
    const index = this.listeners.indexOf(callback)
    if (index > -1) {
      this.listeners.splice(index, 1)
    }
  }
  
  destroy() {
    window.removeEventListener('resize', this.handleResize)
    this.listeners = []
  }
}
```

### 2.3 Vue响应式组合式函数
```javascript
// composables/useBreakpoints.js
import { ref, onMounted, onUnmounted, computed } from 'vue'
import { getCurrentBreakpoint, isMobile, isTablet, isDesktop } from '@/utils/breakpoints'

export function useBreakpoints() {
  const currentBreakpoint = ref('lg')
  const windowWidth = ref(0)
  const windowHeight = ref(0)
  
  const updateBreakpoint = () => {
    currentBreakpoint.value = getCurrentBreakpoint()
    windowWidth.value = window.innerWidth
    windowHeight.value = window.innerHeight
  }
  
  const isMobileDevice = computed(() => isMobile())
  const isTabletDevice = computed(() => isTablet())
  const isDesktopDevice = computed(() => isDesktop())
  
  // 具体断点检查
  const isXs = computed(() => currentBreakpoint.value === 'xs')
  const isSm = computed(() => currentBreakpoint.value === 'sm')
  const isMd = computed(() => currentBreakpoint.value === 'md')
  const isLg = computed(() => currentBreakpoint.value === 'lg')
  const isXl = computed(() => currentBreakpoint.value === 'xl')
  const isXxl = computed(() => currentBreakpoint.value === 'xxl')
  
  // 范围检查
  const isSmAndUp = computed(() => windowWidth.value >= 576)
  const isMdAndUp = computed(() => windowWidth.value >= 768)
  const isLgAndUp = computed(() => windowWidth.value >= 1024)
  const isXlAndUp = computed(() => windowWidth.value >= 1200)
  
  const isSmAndDown = computed(() => windowWidth.value < 768)
  const isMdAndDown = computed(() => windowWidth.value < 1024)
  const isLgAndDown = computed(() => windowWidth.value < 1200)
  const isXlAndDown = computed(() => windowWidth.value < 1600)
  
  onMounted(() => {
    updateBreakpoint()
    window.addEventListener('resize', updateBreakpoint)
  })
  
  onUnmounted(() => {
    window.removeEventListener('resize', updateBreakpoint)
  })
  
  return {
    currentBreakpoint,
    windowWidth,
    windowHeight,
    isMobileDevice,
    isTabletDevice,
    isDesktopDevice,
    isXs,
    isSm,
    isMd,
    isLg,
    isXl,
    isXxl,
    isSmAndUp,
    isMdAndUp,
    isLgAndUp,
    isXlAndUp,
    isSmAndDown,
    isMdAndDown,
    isLgAndDown,
    isXlAndDown
  }
}
```

## 3. 布局系统设计

### 3.1 网格系统
```scss
// styles/grid.scss

// 容器
.container {
  width: 100%;
  margin: 0 auto;
  padding: 0 16px;
  
  @include media-up('sm') {
    max-width: map-get($container-max-widths, 'sm');
    padding: 0 24px;
  }
  
  @include media-up('md') {
    max-width: map-get($container-max-widths, 'md');
  }
  
  @include media-up('lg') {
    max-width: map-get($container-max-widths, 'lg');
  }
  
  @include media-up('xl') {
    max-width: map-get($container-max-widths, 'xl');
  }
  
  @include media-up('xxl') {
    max-width: map-get($container-max-widths, 'xxl');
  }
}

// 流式容器
.container-fluid {
  width: 100%;
  margin: 0 auto;
  padding: 0 16px;
  
  @include media-up('sm') {
    padding: 0 24px;
  }
}

// 行
.row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -8px;
  
  @include media-up('sm') {
    margin: 0 -12px;
  }
  
  @include media-up('md') {
    margin: 0 -16px;
  }
}

// 列
.col {
  flex: 1 0 0%;
  padding: 0 8px;
  
  @include media-up('sm') {
    padding: 0 12px;
  }
  
  @include media-up('md') {
    padding: 0 16px;
  }
}

// 生成响应式列类
@each $breakpoint in map-keys($breakpoints) {
  @include media-up($breakpoint) {
    $infix: if($breakpoint == 'xs', '', '-#{$breakpoint}');
    
    // 自动列
    .col#{$infix} {
      flex: 1 0 0%;
    }
    
    // 固定列
    @for $i from 1 through 12 {
      .col#{$infix}-#{$i} {
        flex: 0 0 auto;
        width: percentage($i / 12);
      }
    }
    
    // 偏移
    @for $i from 0 through 11 {
      .offset#{$infix}-#{$i} {
        margin-left: percentage($i / 12);
      }
    }
    
    // 顺序
    @for $i from 0 through 12 {
      .order#{$infix}-#{$i} {
        order: $i;
      }
    }
  }
}
```

### 3.2 弹性布局组件
```vue
<!-- components/layout/FlexLayout.vue -->
<template>
  <div 
    class="flex-layout"
    :class="flexClasses"
    :style="flexStyles"
  >
    <slot />
  </div>
</template>

<script>
import { computed } from 'vue'

export default {
  name: 'FlexLayout',
  props: {
    direction: {
      type: [String, Object],
      default: 'row',
      validator: (value) => {
        if (typeof value === 'string') {
          return ['row', 'column', 'row-reverse', 'column-reverse'].includes(value)
        }
        return true
      }
    },
    justify: {
      type: [String, Object],
      default: 'flex-start',
      validator: (value) => {
        if (typeof value === 'string') {
          return ['flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'space-evenly'].includes(value)
        }
        return true
      }
    },
    align: {
      type: [String, Object],
      default: 'stretch',
      validator: (value) => {
        if (typeof value === 'string') {
          return ['flex-start', 'flex-end', 'center', 'baseline', 'stretch'].includes(value)
        }
        return true
      }
    },
    wrap: {
      type: [String, Object],
      default: 'nowrap',
      validator: (value) => {
        if (typeof value === 'string') {
          return ['nowrap', 'wrap', 'wrap-reverse'].includes(value)
        }
        return true
      }
    },
    gap: {
      type: [String, Number, Object],
      default: 0
    }
  },
  
  setup(props) {
    const flexClasses = computed(() => {
      const classes = ['flex-layout']
      
      // 处理响应式类名
      const addResponsiveClasses = (prop, prefix) => {
        const value = props[prop]
        if (typeof value === 'string') {
          classes.push(`${prefix}-${value}`)
        } else if (typeof value === 'object') {
          Object.entries(value).forEach(([breakpoint, val]) => {
            if (breakpoint === 'xs') {
              classes.push(`${prefix}-${val}`)
            } else {
              classes.push(`${prefix}-${breakpoint}-${val}`)
            }
          })
        }
      }
      
      addResponsiveClasses('direction', 'flex-direction')
      addResponsiveClasses('justify', 'justify-content')
      addResponsiveClasses('align', 'align-items')
      addResponsiveClasses('wrap', 'flex-wrap')
      
      return classes
    })
    
    const flexStyles = computed(() => {
      const styles = {}
      
      // 处理gap
      if (props.gap) {
        if (typeof props.gap === 'string' || typeof props.gap === 'number') {
          styles.gap = typeof props.gap === 'number' ? `${props.gap}px` : props.gap
        }
      }
      
      return styles
    })
    
    return {
      flexClasses,
      flexStyles
    }
  }
}
</script>

<style scoped>
.flex-layout {
  display: flex;
}

/* 方向类 */
.flex-direction-row { flex-direction: row; }
.flex-direction-column { flex-direction: column; }
.flex-direction-row-reverse { flex-direction: row-reverse; }
.flex-direction-column-reverse { flex-direction: column-reverse; }

/* 主轴对齐 */
.justify-content-flex-start { justify-content: flex-start; }
.justify-content-flex-end { justify-content: flex-end; }
.justify-content-center { justify-content: center; }
.justify-content-space-between { justify-content: space-between; }
.justify-content-space-around { justify-content: space-around; }
.justify-content-space-evenly { justify-content: space-evenly; }

/* 交叉轴对齐 */
.align-items-flex-start { align-items: flex-start; }
.align-items-flex-end { align-items: flex-end; }
.align-items-center { align-items: center; }
.align-items-baseline { align-items: baseline; }
.align-items-stretch { align-items: stretch; }

/* 换行 */
.flex-wrap-nowrap { flex-wrap: nowrap; }
.flex-wrap-wrap { flex-wrap: wrap; }
.flex-wrap-wrap-reverse { flex-wrap: wrap-reverse; }

/* 响应式类 */
@include media-up('sm') {
  .flex-direction-sm-row { flex-direction: row; }
  .flex-direction-sm-column { flex-direction: column; }
  .justify-content-sm-center { justify-content: center; }
  .align-items-sm-center { align-items: center; }
}

@include media-up('md') {
  .flex-direction-md-row { flex-direction: row; }
  .flex-direction-md-column { flex-direction: column; }
  .justify-content-md-center { justify-content: center; }
  .align-items-md-center { align-items: center; }
}

@include media-up('lg') {
  .flex-direction-lg-row { flex-direction: row; }
  .flex-direction-lg-column { flex-direction: column; }
  .justify-content-lg-center { justify-content: center; }
  .align-items-lg-center { align-items: center; }
}
</style>
```

### 3.3 响应式组件包装器
```vue
<!-- components/layout/ResponsiveWrapper.vue -->
<template>
  <component 
    :is="currentComponent"
    v-bind="currentProps"
    :class="currentClasses"
    :style="currentStyles"
  >
    <slot />
  </component>
</template>

<script>
import { computed } from 'vue'
import { useBreakpoints } from '@/composables/useBreakpoints'

export default {
  name: 'ResponsiveWrapper',
  props: {
    // 响应式组件配置
    components: {
      type: Object,
      default: () => ({
        xs: 'div',
        sm: 'div',
        md: 'div',
        lg: 'div',
        xl: 'div',
        xxl: 'div'
      })
    },
    // 响应式属性
    props: {
      type: Object,
      default: () => ({})
    },
    // 响应式类名
    classes: {
      type: Object,
      default: () => ({})
    },
    // 响应式样式
    styles: {
      type: Object,
      default: () => ({})
    }
  },
  
  setup(props) {
    const { currentBreakpoint } = useBreakpoints()
    
    const getResponsiveValue = (config, defaultValue = null) => {
      if (!config) return defaultValue
      
      // 按优先级查找匹配的值
      const breakpoints = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs']
      const currentIndex = breakpoints.indexOf(currentBreakpoint.value)
      
      for (let i = currentIndex; i < breakpoints.length; i++) {
        const breakpoint = breakpoints[i]
        if (config[breakpoint] !== undefined) {
          return config[breakpoint]
        }
      }
      
      return defaultValue
    }
    
    const currentComponent = computed(() => {
      return getResponsiveValue(props.components, 'div')
    })
    
    const currentProps = computed(() => {
      const baseProps = {}
      
      Object.keys(props.props).forEach(key => {
        baseProps[key] = getResponsiveValue(props.props[key], props.props[key])
      })
      
      return baseProps
    })
    
    const currentClasses = computed(() => {
      return getResponsiveValue(props.classes, [])
    })
    
    const currentStyles = computed(() => {
      const baseStyles = {}
      
      Object.keys(props.styles).forEach(key => {
        baseStyles[key] = getResponsiveValue(props.styles[key], props.styles[key])
      })
      
      return baseStyles
    })
    
    return {
      currentComponent,
      currentProps,
      currentClasses,
      currentStyles
    }
  }
}
</script>
```

## 4. 组件响应式适配

### 4.1 导航栏响应式适配
```vue
<!-- components/navigation/ResponsiveNavbar.vue -->
<template>
  <nav class="responsive-navbar" :class="navbarClasses">
    <!-- 桌面端导航 -->
    <div v-if="isDesktopDevice" class="desktop-nav">
      <div class="nav-brand">
        <router-link to="/" class="brand-link">
          <img src="/logo.svg" alt="Alpha" class="brand-logo" />
          <span class="brand-text">Alpha</span>
        </router-link>
      </div>
      
      <div class="nav-menu">
        <router-link 
          v-for="item in menuItems" 
          :key="item.path"
          :to="item.path"
          class="nav-link"
          :class="{ active: $route.path.startsWith(item.path) }"
        >
          <i :class="item.icon"></i>
          <span>{{ item.label }}</span>
        </router-link>
      </div>
      
      <div class="nav-actions">
        <el-button circle size="small" @click="showSearch = true">
          <i class="icon-search"></i>
        </el-button>
        <el-badge :value="notificationCount">
          <el-button circle size="small" @click="showNotifications = true">
            <i class="icon-notification"></i>
          </el-button>
        </el-badge>
        <UserDropdown />
      </div>
    </div>
    
    <!-- 移动端导航 -->
    <div v-else class="mobile-nav">
      <div class="mobile-header">
        <el-button 
          circle 
          size="small" 
          @click="toggleMobileMenu"
          class="menu-toggle"
        >
          <i :class="mobileMenuVisible ? 'icon-close' : 'icon-menu'"></i>
        </el-button>
        
        <div class="nav-brand">
          <router-link to="/" class="brand-link">
            <img src="/logo.svg" alt="Alpha" class="brand-logo" />
            <span v-if="!isXs" class="brand-text">Alpha</span>
          </router-link>
        </div>
        
        <div class="mobile-actions">
          <el-badge :value="notificationCount" :hidden="notificationCount === 0">
            <el-button circle size="small" @click="showNotifications = true">
              <i class="icon-notification"></i>
            </el-button>
          </el-badge>
          <el-avatar :size="32" :src="userInfo.avatar" />
        </div>
      </div>
      
      <!-- 移动端菜单抽屉 -->
      <el-drawer
        v-model="mobileMenuVisible"
        direction="ltr"
        size="280px"
        :show-close="false"
        class="mobile-menu-drawer"
      >
        <div class="mobile-menu">
          <div class="menu-header">
            <el-avatar :size="48" :src="userInfo.avatar" />
            <div class="user-info">
              <h4>{{ userInfo.username }}</h4>
              <p>{{ userInfo.email }}</p>
            </div>
          </div>
          
          <div class="menu-items">
            <router-link 
              v-for="item in menuItems" 
              :key="item.path"
              :to="item.path"
              class="menu-item"
              :class="{ active: $route.path.startsWith(item.path) }"
              @click="closeMobileMenu"
            >
              <i :class="item.icon"></i>
              <span>{{ item.label }}</span>
              <i class="icon-arrow-right"></i>
            </router-link>
          </div>
          
          <div class="menu-footer">
            <el-button @click="showSettings = true" text>
              <i class="icon-settings"></i>
              设置
            </el-button>
            <el-button @click="handleLogout" text>
              <i class="icon-logout"></i>
              退出
            </el-button>
          </div>
        </div>
      </el-drawer>
    </div>
    
    <!-- 底部导航 (仅移动端) -->
    <div v-if="isMobileDevice" class="bottom-navigation">
      <div 
        v-for="item in bottomNavItems" 
        :key="item.path"
        class="bottom-nav-item"
        :class="{ active: $route.path.startsWith(item.path) }"
        @click="$router.push(item.path)"
      >
        <i :class="item.icon"></i>
        <span>{{ item.label }}</span>
        <div v-if="item.badge" class="nav-badge">{{ item.badge }}</div>
      </div>
    </div>
  </nav>
</template>

<script>
import { ref, computed } from 'vue'
import { useBreakpoints } from '@/composables/useBreakpoints'
import { useUserStore } from '@/stores/user'
import UserDropdown from './UserDropdown.vue'

export default {
  name: 'ResponsiveNavbar',
  components: {
    UserDropdown
  },
  
  setup() {
    const { 
      isDesktopDevice, 
      isMobileDevice, 
      isXs 
    } = useBreakpoints()
    const userStore = useUserStore()
    
    const mobileMenuVisible = ref(false)
    const showSearch = ref(false)
    const showNotifications = ref(false)
    const showSettings = ref(false)
    const notificationCount = ref(3)
    
    const userInfo = computed(() => userStore.userInfo)
    
    const menuItems = [
      { path: '/blog', label: '博客', icon: 'icon-blog' },
      { path: '/english', label: '英语学习', icon: 'icon-english' },
      { path: '/job', label: '求职管理', icon: 'icon-job' },
      { path: '/todo', label: '待办笔记', icon: 'icon-todo' },
      { path: '/ai', label: 'AI助手', icon: 'icon-ai' }
    ]
    
    const bottomNavItems = [
      { path: '/blog', label: '博客', icon: 'icon-blog' },
      { path: '/english', label: '学习', icon: 'icon-english' },
      { path: '/todo', label: '待办', icon: 'icon-todo', badge: 3 },
      { path: '/ai', label: 'AI', icon: 'icon-ai' },
      { path: '/more', label: '更多', icon: 'icon-more' }
    ]
    
    const navbarClasses = computed(() => [
      'responsive-navbar',
      {
        'desktop-layout': isDesktopDevice.value,
        'mobile-layout': isMobileDevice.value
      }
    ])
    
    const toggleMobileMenu = () => {
      mobileMenuVisible.value = !mobileMenuVisible.value
    }
    
    const closeMobileMenu = () => {
      mobileMenuVisible.value = false
    }
    
    const handleLogout = async () => {
      try {
        await userStore.logout()
        closeMobileMenu()
      } catch (error) {
        console.error('Logout failed:', error)
      }
    }
    
    return {
      isDesktopDevice,
      isMobileDevice,
      isXs,
      mobileMenuVisible,
      showSearch,
      showNotifications,
      showSettings,
      notificationCount,
      userInfo,
      menuItems,
      bottomNavItems,
      navbarClasses,
      toggleMobileMenu,
      closeMobileMenu,
      handleLogout
    }
  }
}
</script>

<style scoped>
.responsive-navbar {
  position: relative;
  z-index: 1000;
}

/* 桌面端样式 */
.desktop-nav {
  display: flex;
  align-items: center;
  height: 60px;
  padding: 0 24px;
  background: var(--background-color);
  border-bottom: 1px solid var(--border-color);
}

.nav-brand {
  margin-right: 40px;
}

.brand-link {
  display: flex;
  align-items: center;
  text-decoration: none;
  color: var(--primary-color);
  font-size: 20px;
  font-weight: bold;
}

.brand-logo {
  width: 32px;
  height: 32px;
  margin-right: 8px;
}

.nav-menu {
  flex: 1;
  display: flex;
  gap: 8px;
}

.nav-link {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  text-decoration: none;
  color: var(--text-color-secondary);
  border-radius: 8px;
  transition: all 0.3s ease;
  font-size: 14px;
  font-weight: 500;
}

.nav-link:hover,
.nav-link.active {
  color: var(--primary-color);
  background-color: var(--primary-color-light);
}

.nav-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

/* 移动端样式 */
.mobile-nav {
  position: relative;
}

.mobile-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 56px;
  padding: 0 16px;
  background: var(--background-color);
  border-bottom: 1px solid var(--border-color);
}

.menu-toggle {
  margin-right: 12px;
}

.mobile-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

.mobile-menu {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.menu-header {
  padding: 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  gap: 16px;
}

.user-info h4 {
  margin: 0 0 4px 0;
  font-size: 16px;
  font-weight: 600;
}

.user-info p {
  margin: 0;
  font-size: 14px;
  color: var(--text-color-secondary);
}

.menu-items {
  flex: 1;
  padding: 16px 0;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 16px 24px;
  text-decoration: none;
  color: var(--text-color-primary);
  transition: background-color 0.3s ease;
}

.menu-item:hover,
.menu-item.active {
  background-color: var(--hover-background);
}

.menu-item i:first-child {
  width: 20px;
  font-size: 18px;
}

.menu-item span {
  flex: 1;
  font-size: 16px;
}

.menu-item i:last-child {
  font-size: 14px;
  color: var(--text-color-secondary);
}

.menu-footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

/* 底部导航 */
.bottom-navigation {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  background: var(--background-color);
  border-top: 1px solid var(--border-color);
  padding: 8px 0;
  padding-bottom: env(safe-area-inset-bottom, 8px);
  z-index: 1000;
}

.bottom-nav-item {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px 4px;
  cursor: pointer;
  position: relative;
  transition: all 0.3s ease;
}

.bottom-nav-item i {
  font-size: 20px;
  color: var(--text-color-secondary);
  margin-bottom: 4px;
}

.bottom-nav-item span {
  font-size: 10px;
  color: var(--text-color-secondary);
}

.bottom-nav-item.active i,
.bottom-nav-item.active span {
  color: var(--primary-color);
}

.nav-badge {
  position: absolute;
  top: 4px;
  right: 20%;
  background: var(--error-color);
  color: white;
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 10px;
  min-width: 16px;
  text-align: center;
}

/* 响应式调整 */
@include media-only('xs') {
  .mobile-header {
    height: 52px;
    padding: 0 12px;
  }
  
  .brand-text {
    display: none;
  }
}

@include media-up('lg') {
  .mobile-nav,
  .bottom-navigation {
    display: none;
  }
}

@include media-down('lg') {
  .desktop-nav {
    display: none;
  }
}
</style>
```

### 4.2 卡片组件响应式适配
```vue
<!-- components/common/ResponsiveCard.vue -->
<template>
  <div class="responsive-card" :class="cardClasses" :style="cardStyles">
    <div v-if="showHeader" class="card-header">
      <slot name="header">
        <h3 v-if="title" class="card-title">{{ title }}</h3>
      </slot>
      <div v-if="$slots.actions" class="card-actions">
        <slot name="actions" />
      </div>
    </div>
    
    <div class="card-body" :style="bodyStyles">
      <slot />
    </div>
    
    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<script>
import { computed } from 'vue'
import { useBreakpoints } from '@/composables/useBreakpoints'

export default {
  name: 'ResponsiveCard',
  props: {
    title: {
      type: String,
      default: ''
    },
    shadow: {
      type: [String, Object],
      default: 'hover',
      validator: (value) => {
        if (typeof value === 'string') {
          return ['always', 'hover', 'never'].includes(value)
        }
        return true
      }
    },
    padding: {
      type: [String, Object],
      default: 'normal'
    },
    radius: {
      type: [String, Object],
      default: 'normal'
    },
    border: {
      type: [Boolean, Object],
      default: true
    }
  },
  
  setup(props, { slots }) {
    const { currentBreakpoint, isMobileDevice } = useBreakpoints()
    
    const showHeader = computed(() => {
      return props.title || slots.header || slots.actions
    })
    
    const getResponsiveValue = (value, defaultValue) => {
      if (typeof value === 'object' && value !== null) {
        return value[currentBreakpoint.value] || 
               value.lg || value.md || value.sm || value.xs || 
               defaultValue
      }
      return value || defaultValue
    }
    
    const cardClasses = computed(() => {
      const classes = ['responsive-card']
      
      // 阴影
      const shadowValue = getResponsiveValue(props.shadow, 'hover')
      classes.push(`shadow-${shadowValue}`)
      
      // 边框
      const borderValue = getResponsiveValue(props.border, true)
      if (borderValue) {
        classes.push('with-border')
      }
      
      // 移动端适配
      if (isMobileDevice.value) {
        classes.push('mobile-card')
      }
      
      return classes
    })
    
    const cardStyles = computed(() => {
      const styles = {}
      
      // 圆角
      const radiusValue = getResponsiveValue(props.radius, 'normal')
      const radiusMap = {
        none: '0',
        small: '4px',
        normal: '8px',
        large: '12px',
        round: '16px'
      }
      
      if (radiusMap[radiusValue]) {
        styles.borderRadius = radiusMap[radiusValue]
      } else if (typeof radiusValue === 'string') {
        styles.borderRadius = radiusValue
      }
      
      return styles
    })
    
    const bodyStyles = computed(() => {
      const styles = {}
      
      // 内边距
      const paddingValue = getResponsiveValue(props.padding, 'normal')
      const paddingMap = {
        none: '0',
        small: isMobileDevice.value ? '12px' : '16px',
        normal: isMobileDevice.value ? '16px' : '24px',
        large: isMobileDevice.value ? '20px' : '32px'
      }
      
      if (paddingMap[paddingValue]) {
        styles.padding = paddingMap[paddingValue]
      } else if (typeof paddingValue === 'string') {
        styles.padding = paddingValue
      }
      
      return styles
    })
    
    return {
      showHeader,
      cardClasses,
      cardStyles,
      bodyStyles
    }
  }
}
</script>

<style scoped>
.responsive-card {
  background: var(--card-background);
  transition: all 0.3s ease;
  overflow: hidden;
}

.with-border {
  border: 1px solid var(--border-color);
}

.shadow-always {
  box-shadow: var(--card-shadow);
}

.shadow-hover:hover {
  box-shadow: var(--card-shadow-hover);
}

.shadow-never {
  box-shadow: none;
}

.card-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  background: var(--card-header-background);
}

.card-title {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--text-color-primary);
}

.card-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.card-body {
  padding: 24px;
}

.card-footer {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  background: var(--card-footer-background);
}

/* 移动端适配 */
.mobile-card {
  border-radius: 0 !important;
  border-left: none !important;
  border-right: none !important;
}

.mobile-card .card-header {
  padding: 12px 16px;
}

.mobile-card .card-title {
  font-size: 16px;
}

.mobile-card .card-body {
  padding: 16px;
}

.mobile-card .card-footer {
  padding: 12px 16px;
}

/* 响应式断点调整 */
@include media-down('sm') {
  .card-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }
  
  .card-actions {
    width: 100%;
    justify-content: flex-end;
  }
}
</style>
```

## 5. 触摸和手势支持

### 5.1 触摸优化组合式函数
```javascript
// composables/useTouch.js
import { ref, onMounted, onUnmounted } from 'vue'

export function useTouch(element) {
  const isTouch = ref(false)
  const touchStart = ref({ x: 0, y: 0, time: 0 })
  const touchEnd = ref({ x: 0, y: 0, time: 0 })
  
  const handleTouchStart = (event) => {
    isTouch.value = true
    const touch = event.touches[0]
    touchStart.value = {
      x: touch.clientX,
      y: touch.clientY,
      time: Date.now()
    }
  }
  
  const handleTouchEnd = (event) => {
    const touch = event.changedTouches[0]
    touchEnd.value = {
      x: touch.clientX,
      y: touch.clientY,
      time: Date.now()
    }
    
    // 计算手势
    const deltaX = touchEnd.value.x - touchStart.value.x
    const deltaY = touchEnd.value.y - touchStart.value.y
    const deltaTime = touchEnd.value.time - touchStart.value.time
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)
    
    // 判断手势类型
    if (deltaTime < 300 && distance < 10) {
      // 点击
      emitGesture('tap', { x: touchEnd.value.x, y: touchEnd.value.y })
    } else if (deltaTime < 500 && distance > 30) {
      // 滑动
      const direction = getSwipeDirection(deltaX, deltaY)
      emitGesture('swipe', { direction, distance, deltaX, deltaY })
    } else if (deltaTime > 500 && distance < 10) {
      // 长按
      emitGesture('longpress', { x: touchEnd.value.x, y: touchEnd.value.y })
    }
    
    setTimeout(() => {
      isTouch.value = false
    }, 100)
  }
  
  const getSwipeDirection = (deltaX, deltaY) => {
    const absX = Math.abs(deltaX)
    const absY = Math.abs(deltaY)
    
    if (absX > absY) {
      return deltaX > 0 ? 'right' : 'left'
    } else {
      return deltaY > 0 ? 'down' : 'up'
    }
  }
  
  const emitGesture = (type, data) => {
    if (element.value) {
      element.value.dispatchEvent(new CustomEvent(`gesture-${type}`, {
        detail: data
      }))
    }
  }
  
  onMounted(() => {
    if (element.value) {
      element.value.addEventListener('touchstart', handleTouchStart, { passive: true })
      element.value.addEventListener('touchend', handleTouchEnd, { passive: true })
    }
  })
  
  onUnmounted(() => {
    if (element.value) {
      element.value.removeEventListener('touchstart', handleTouchStart)
      element.value.removeEventListener('touchend', handleTouchEnd)
    }
  })
  
  return {
    isTouch
  }
}
```

### 5.2 滑动组件
```vue
<!-- components/gesture/SwipeableCard.vue -->
<template>
  <div 
    ref="cardRef"
    class="swipeable-card"
    :class="{ swiping: isSwiping }"
    :style="cardStyles"
    @touchstart="handleTouchStart"
    @touchmove="handleTouchMove"
    @touchend="handleTouchEnd"
    @transitionend="handleTransitionEnd"
  >
    <!-- 左侧操作区域 -->
    <div class="swipe-actions swipe-actions-left" :style="leftActionsStyles">
      <slot name="left-actions">
        <div class="action-item action-primary" @click="handleLeftAction">
          <i class="icon-check"></i>
          <span>完成</span>
        </div>
      </slot>
    </div>
    
    <!-- 主内容区域 -->
    <div class="card-content">
      <slot />
    </div>
    
    <!-- 右侧操作区域 -->
    <div class="swipe-actions swipe-actions-right" :style="rightActionsStyles">
      <slot name="right-actions">
        <div class="action-item action-warning" @click="handleRightAction">
          <i class="icon-edit"></i>
          <span>编辑</span>
        </div>
        <div class="action-item action-danger" @click="handleDeleteAction">
          <i class="icon-delete"></i>
          <span>删除</span>
        </div>
      </slot>
    </div>
  </div>
</template>

<script>
import { ref, computed, nextTick } from 'vue'

export default {
  name: 'SwipeableCard',
  props: {
    leftActions: {
      type: Array,
      default: () => []
    },
    rightActions: {
      type: Array,
      default: () => []
    },
    threshold: {
      type: Number,
      default: 80
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  
  emits: ['left-action', 'right-action', 'delete'],
  
  setup(props, { emit }) {
    const cardRef = ref()
    const isSwiping = ref(false)
    const startX = ref(0)
    const currentX = ref(0)
    const translateX = ref(0)
    const isAnimating = ref(false)
    
    const cardStyles = computed(() => ({
      transform: `translateX(${translateX.value}px)`,
      transition: isAnimating.value ? 'transform 0.3s ease-out' : 'none'
    }))
    
    const leftActionsStyles = computed(() => ({
      transform: `translateX(${Math.min(0, translateX.value - 100)}px)`,
      opacity: translateX.value > 0 ? 1 : 0
    }))
    
    const rightActionsStyles = computed(() => ({
      transform: `translateX(${Math.max(0, translateX.value + 100)}px)`,
      opacity: translateX.value < 0 ? 1 : 0
    }))
    
    const handleTouchStart = (event) => {
      if (props.disabled) return
      
      isSwiping.value = true
      startX.value = event.touches[0].clientX
      currentX.value = startX.value
      isAnimating.value = false
    }
    
    const handleTouchMove = (event) => {
      if (!isSwiping.value || props.disabled) return
      
      currentX.value = event.touches[0].clientX
      const deltaX = currentX.value - startX.value
      
      // 限制滑动范围
      const maxLeft = 120
      const maxRight = -160
      
      translateX.value = Math.max(maxRight, Math.min(maxLeft, deltaX))
    }
    
    const handleTouchEnd = () => {
      if (!isSwiping.value || props.disabled) return
      
      isSwiping.value = false
      isAnimating.value = true
      
      const deltaX = currentX.value - startX.value
      
      if (Math.abs(deltaX) < props.threshold) {
        // 回弹到原位
        translateX.value = 0
      } else if (deltaX > 0) {
        // 向右滑动，显示左侧操作
        translateX.value = 100
      } else {
        // 向左滑动，显示右侧操作
        translateX.value = -140
      }
    }
    
    const handleTransitionEnd = () => {
      isAnimating.value = false
    }
    
    const resetPosition = () => {
      isAnimating.value = true
      translateX.value = 0
    }
    
    const handleLeftAction = () => {
      emit('left-action')
      resetPosition()
    }
    
    const handleRightAction = () => {
      emit('right-action')
      resetPosition()
    }
    
    const handleDeleteAction = () => {
      emit('delete')
      resetPosition()
    }
    
    return {
      cardRef,
      isSwiping,
      cardStyles,
      leftActionsStyles,
      rightActionsStyles,
      handleTouchStart,
      handleTouchMove,
      handleTouchEnd,
      handleTransitionEnd,
      handleLeftAction,
      handleRightAction,
      handleDeleteAction,
      resetPosition
    }
  }
}
</script>

<style scoped>
.swipeable-card {
  position: relative;
  background: var(--card-background);
  border-radius: 8px;
  overflow: hidden;
  touch-action: pan-y;
  user-select: none;
}

.swipeable-card.swiping {
  z-index: 10;
}

.card-content {
  position: relative;
  z-index: 2;
  background: var(--card-background);
  padding: 16px;
}

.swipe-actions {
  position: absolute;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  z-index: 1;
}

.swipe-actions-left {
  left: 0;
  background: linear-gradient(90deg, var(--success-color), var(--success-color-light));
}

.swipe-actions-right {
  right: 0;
  background: linear-gradient(90deg, var(--warning-color), var(--error-color));
}

.action-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-width: 80px;
  height: 100%;
  color: white;
  cursor: pointer;
  transition: background-color 0.3s ease;
  padding: 0 16px;
}

.action-item:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.action-item i {
  font-size: 20px;
  margin-bottom: 4px;
}

.action-item span {
  font-size: 12px;
  font-weight: 500;
}

.action-primary {
  background-color: var(--success-color);
}

.action-warning {
  background-color: var(--warning-color);
}

.action-danger {
  background-color: var(--error-color);
}
</style>
```

## 6. 性能优化

### 6.1 图片响应式加载
```vue
<!-- components/common/ResponsiveImage.vue -->
<template>
  <div class="responsive-image-wrapper" :style="wrapperStyles">
    <img
      ref="imageRef"
      :src="currentSrc"
      :alt="alt"
      :loading="loading"
      class="responsive-image"
      :class="imageClasses"
      @load="handleLoad"
      @error="handleError"
    />
    
    <div v-if="isLoading" class="image-placeholder">
      <div class="loading-spinner"></div>
    </div>
    
    <div v-if="hasError" class="image-error">
      <i class="icon-image-error"></i>
      <span>图片加载失败</span>
    </div>
  </div>
</template>

<script>
import { ref, computed, watch } from 'vue'
import { useBreakpoints } from '@/composables/useBreakpoints'

export default {
  name: 'ResponsiveImage',
  props: {
    src: {
      type: [String, Object],
      required: true
    },
    alt: {
      type: String,
      default: ''
    },
    aspectRatio: {
      type: [String, Number],
      default: 'auto'
    },
    objectFit: {
      type: String,
      default: 'cover',
      validator: (value) => ['cover', 'contain', 'fill', 'none', 'scale-down'].includes(value)
    },
    loading: {
      type: String,
      default: 'lazy',
      validator: (value) => ['lazy', 'eager'].includes(value)
    },
    sizes: {
      type: String,
      default: '100vw'
    }
  },
  
  setup(props) {
    const imageRef = ref()
    const isLoading = ref(true)
    const hasError = ref(false)
    const { currentBreakpoint } = useBreakpoints()
    
    const currentSrc = computed(() => {
      if (typeof props.src === 'string') {
        return props.src
      }
      
      // 响应式图片源
      const breakpoints = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs']
      const currentIndex = breakpoints.indexOf(currentBreakpoint.value)
      
      for (let i = currentIndex; i < breakpoints.length; i++) {
        const breakpoint = breakpoints[i]
        if (props.src[breakpoint]) {
          return props.src[breakpoint]
        }
      }
      
      return props.src.default || props.src.lg || props.src.md || props.src.sm || ''
    })
    
    const wrapperStyles = computed(() => {
      const styles = {}
      
      if (props.aspectRatio && props.aspectRatio !== 'auto') {
        if (typeof props.aspectRatio === 'number') {
          styles.aspectRatio = props.aspectRatio
        } else {
          styles.aspectRatio = props.aspectRatio
        }
      }
      
      return styles
    })
    
    const imageClasses = computed(() => [
      'responsive-image',
      `object-fit-${props.objectFit}`,
      {
        'loading': isLoading.value,
        'error': hasError.value
      }
    ])
    
    const handleLoad = () => {
      isLoading.value = false
      hasError.value = false
    }
    
    const handleError = () => {
      isLoading.value = false
      hasError.value = true
    }
    
    // 监听src变化，重置状态
    watch(() => currentSrc.value, () => {
      isLoading.value = true
      hasError.value = false
    })
    
    return {
      imageRef,
      isLoading,
      hasError,
      currentSrc,
      wrapperStyles,
      imageClasses,
      handleLoad,
      handleError
    }
  }
}
</script>

<style scoped>
.responsive-image-wrapper {
  position: relative;
  overflow: hidden;
  background-color: var(--background-color-light);
}

.responsive-image {
  width: 100%;
  height: 100%;
  transition: opacity 0.3s ease;
}

.object-fit-cover { object-fit: cover; }
.object-fit-contain { object-fit: contain; }
.object-fit-fill { object-fit: fill; }
.object-fit-none { object-fit: none; }
.object-fit-scale-down { object-fit: scale-down; }

.responsive-image.loading {
  opacity: 0;
}

.image-placeholder,
.image-error {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  background-color: var(--background-color-light);
}

.loading-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid var(--border-color);
  border-top: 3px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.image-error {
  color: var(--text-color-secondary);
  font-size: 14px;
}

.image-error i {
  font-size: 32px;
  margin-bottom: 8px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
```

### 6.2 虚拟滚动组件
```vue
<!-- components/common/VirtualScroller.vue -->
<template>
  <div 
    ref="containerRef"
    class="virtual-scroller"
    :style="containerStyles"
    @scroll="handleScroll"
  >
    <div class="virtual-scroller-content" :style="contentStyles">
      <div
        v-for="(item, index) in visibleItems"
        :key="getItemKey(item, startIndex + index)"
        class="virtual-item"
        :style="getItemStyles(startIndex + index)"
      >
        <slot :item="item" :index="startIndex + index" />
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted, onUnmounted, nextTick } from 'vue'
import { useBreakpoints } from '@/composables/useBreakpoints'

export default {
  name: 'VirtualScroller',
  props: {
    items: {
      type: Array,
      required: true
    },
    itemHeight: {
      type: [Number, Function],
      default: 60
    },
    containerHeight: {
      type: [Number, String],
      default: 400
    },
    buffer: {
      type: Number,
      default: 5
    },
    keyField: {
      type: String,
      default: 'id'
    }
  },
  
  setup(props) {
    const containerRef = ref()
    const scrollTop = ref(0)
    const { isMobileDevice } = useBreakpoints()
    
    const getItemHeight = (index) => {
      if (typeof props.itemHeight === 'function') {
        return props.itemHeight(index, props.items[index])
      }
      return props.itemHeight
    }
    
    const containerStyles = computed(() => ({
      height: typeof props.containerHeight === 'number' 
        ? `${props.containerHeight}px` 
        : props.containerHeight,
      overflow: 'auto',
      position: 'relative'
    }))
    
    const totalHeight = computed(() => {
      return props.items.reduce((total, _, index) => {
        return total + getItemHeight(index)
      }, 0)
    })
    
    const contentStyles = computed(() => ({
      height: `${totalHeight.value}px`,
      position: 'relative'
    }))
    
    const visibleRange = computed(() => {
      const containerHeight = typeof props.containerHeight === 'number' 
        ? props.containerHeight 
        : containerRef.value?.clientHeight || 400
      
      let startIndex = 0
      let accumulatedHeight = 0
      
      // 找到开始索引
      for (let i = 0; i < props.items.length; i++) {
        const itemHeight = getItemHeight(i)
        if (accumulatedHeight + itemHeight > scrollTop.value) {
          startIndex = Math.max(0, i - props.buffer)
          break
        }
        accumulatedHeight += itemHeight
      }
      
      // 找到结束索引
      let endIndex = startIndex
      accumulatedHeight = 0
      
      for (let i = startIndex; i < props.items.length; i++) {
        accumulatedHeight += getItemHeight(i)
        if (accumulatedHeight > containerHeight + props.buffer * getItemHeight(i)) {
          endIndex = Math.min(props.items.length - 1, i + props.buffer)
          break
        }
        endIndex = i
      }
      
      return { startIndex, endIndex }
    })
    
    const startIndex = computed(() => visibleRange.value.startIndex)
    const endIndex = computed(() => visibleRange.value.endIndex)
    
    const visibleItems = computed(() => {
      return props.items.slice(startIndex.value, endIndex.value + 1)
    })
    
    const getItemStyles = (index) => {
      let top = 0
      for (let i = 0; i < index; i++) {
        top += getItemHeight(i)
      }
      
      return {
        position: 'absolute',
        top: `${top}px`,
        left: 0,
        right: 0,
        height: `${getItemHeight(index)}px`
      }
    }
    
    const getItemKey = (item, index) => {
      return item[props.keyField] || index
    }
    
    const handleScroll = (event) => {
      scrollTop.value = event.target.scrollTop
    }
    
    const scrollToIndex = (index) => {
      if (!containerRef.value) return
      
      let top = 0
      for (let i = 0; i < index; i++) {
        top += getItemHeight(i)
      }
      
      containerRef.value.scrollTop = top
    }
    
    const scrollToTop = () => {
      if (containerRef.value) {
        containerRef.value.scrollTop = 0
      }
    }
    
    const scrollToBottom = () => {
      if (containerRef.value) {
        containerRef.value.scrollTop = totalHeight.value
      }
    }
    
    // 响应式调整
    const handleResize = () => {
      nextTick(() => {
        // 触发重新计算
        scrollTop.value = containerRef.value?.scrollTop || 0
      })
    }
    
    onMounted(() => {
      window.addEventListener('resize', handleResize)
    })
    
    onUnmounted(() => {
      window.removeEventListener('resize', handleResize)
    })
    
    return {
      containerRef,
      containerStyles,
      contentStyles,
      visibleItems,
      startIndex,
      getItemStyles,
      getItemKey,
      handleScroll,
      scrollToIndex,
      scrollToTop,
      scrollToBottom
    }
  }
}
</script>

<style scoped>
.virtual-scroller {
  position: relative;
}

.virtual-scroller-content {
  position: relative;
}

.virtual-item {
  position: absolute;
  width: 100%;
}

/* 移动端优化 */
@include media-down('md') {
  .virtual-scroller {
    -webkit-overflow-scrolling: touch;
  }
}
</style>
```

## 7. 响应式测试工具

### 7.1 设备预览组件
```vue
<!-- components/dev/DevicePreview.vue -->
<template>
  <div class="device-preview" v-if="isDevelopment">
    <div class="preview-controls">
      <el-select v-model="selectedDevice" @change="switchDevice">
        <el-option 
          v-for="device in devices" 
          :key="device.name"
          :label="device.name"
          :value="device.name"
        />
      </el-select>
      
      <el-button @click="toggleOrientation" size="small">
        <i :class="isLandscape ? 'icon-portrait' : 'icon-landscape'"></i>
        {{ isLandscape ? '竖屏' : '横屏' }}
      </el-button>
      
      <el-button @click="showGrid = !showGrid" size="small">
        <i class="icon-grid"></i>
        网格
      </el-button>
    </div>
    
    <div class="preview-container" :class="{ 'show-grid': showGrid }">
      <div 
        class="device-frame"
        :class="[currentDevice.type, { landscape: isLandscape }]"
        :style="deviceStyles"
      >
        <div class="device-screen">
          <iframe
            :src="previewUrl"
            class="preview-iframe"
            frameborder="0"
          />
        </div>
      </div>
    </div>
    
    <div class="device-info">
      <p>设备: {{ currentDevice.name }}</p>
      <p>尺寸: {{ currentWidth }}x{{ currentHeight }}px</p>
      <p>密度: {{ currentDevice.pixelRatio }}x</p>
      <p>断点: {{ currentBreakpoint }}</p>
    </div>
  </div>
</template>

<script>
import { ref, computed } from 'vue'

export default {
  name: 'DevicePreview',
  
  setup() {
    const isDevelopment = process.env.NODE_ENV === 'development'
    const selectedDevice = ref('iPhone 12')
    const isLandscape = ref(false)
    const showGrid = ref(false)
    
    const devices = [
      {
        name: 'iPhone SE',
        type: 'mobile',
        width: 375,
        height: 667,
        pixelRatio: 2
      },
      {
        name: 'iPhone 12',
        type: 'mobile',
        width: 390,
        height: 844,
        pixelRatio: 3
      },
      {
        name: 'iPhone 12 Pro Max',
        type: 'mobile',
        width: 428,
        height: 926,
        pixelRatio: 3
      },
      {
        name: 'iPad',
        type: 'tablet',
        width: 768,
        height: 1024,
        pixelRatio: 2
      },
      {
        name: 'iPad Pro',
        type: 'tablet',
        width: 1024,
        height: 1366,
        pixelRatio: 2
      },
      {
        name: 'MacBook Air',
        type: 'desktop',
        width: 1440,
        height: 900,
        pixelRatio: 2
      },
      {
        name: 'Desktop',
        type: 'desktop',
        width: 1920,
        height: 1080,
        pixelRatio: 1
      }
    ]
    
    const currentDevice = computed(() => {
      return devices.find(d => d.name === selectedDevice.value) || devices[0]
    })
    
    const currentWidth = computed(() => {
      return isLandscape.value ? currentDevice.value.height : currentDevice.value.width
    })
    
    const currentHeight = computed(() => {
      return isLandscape.value ? currentDevice.value.width : currentDevice.value.height
    })
    
    const deviceStyles = computed(() => ({
      width: `${currentWidth.value}px`,
      height: `${currentHeight.value}px`
    }))
    
    const currentBreakpoint = computed(() => {
      const width = currentWidth.value
      if (width >= 1600) return 'xxl'
      if (width >= 1200) return 'xl'
      if (width >= 1024) return 'lg'
      if (width >= 768) return 'md'
      if (width >= 576) return 'sm'
      return 'xs'
    })
    
    const previewUrl = computed(() => {
      const url = new URL(window.location.href)
      url.searchParams.set('preview', 'true')
      url.searchParams.set('device', currentDevice.value.name)
      url.searchParams.set('width', currentWidth.value)
      url.searchParams.set('height', currentHeight.value)
      return url.toString()
    })
    
    const switchDevice = () => {
      isLandscape.value = false
    }
    
    const toggleOrientation = () => {
      isLandscape.value = !isLandscape.value
    }
    
    return {
      isDevelopment,
      selectedDevice,
      isLandscape,
      showGrid,
      devices,
      currentDevice,
      currentWidth,
      currentHeight,
      deviceStyles,
      currentBreakpoint,
      previewUrl,
      switchDevice,
      toggleOrientation
    }
  }
}
</script>

<style scoped>
.device-preview {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f5f5f5;
  z-index: 9999;
  padding: 20px;
  overflow: auto;
}

.preview-controls {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-bottom: 20px;
  padding: 16px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.preview-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 600px;
  position: relative;
}

.preview-container.show-grid::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-image: 
    linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
    linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
  background-size: 20px 20px;
  pointer-events: none;
}

.device-frame {
  position: relative;
  background: #333;
  border-radius: 20px;
  padding: 20px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.device-frame.mobile {
  border-radius: 25px;
  padding: 30px 15px;
}

.device-frame.tablet {
  border-radius: 15px;
  padding: 25px;
}

.device-frame.desktop {
  border-radius: 8px;
  padding: 10px;
  background: #000;
}

.device-frame.landscape {
  transform: rotate(0deg);
}

.device-screen {
  width: 100%;
  height: 100%;
  background: white;
  border-radius: 8px;
  overflow: hidden;
}

.preview-iframe {
  width: 100%;
  height: 100%;
  border: none;
}

.device-info {
  margin-top: 20px;
  padding: 16px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.device-info p {
  margin: 4px 0;
  font-size: 14px;
  color: #666;
}
</style>
```

这套响应式设计系统提供了完整的多设备适配解决方案，包括断点系统、布局适配、组件响应式、触摸优化、性能优化等各个方面，确保平台在不同设备上都能提供优秀的用户体验。

