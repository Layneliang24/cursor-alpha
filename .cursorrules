# Cursor AI 项目规则（团队共识）

**警告⚠️：大模型要严格遵守以下规则，否则会受到惩罚，如有违反，请立即停止工作，并通知我，如有矛盾的规则，请立即停止工作，并通知我**

---

## 🔴 核心规则（必须遵循）

### 对话规范：
- 回答规范：每次对话，请标注是由哪个模型回答的，并给出真实模型名称。
- 输出语言：简体中文；回复力求简洁明了，节约token。
- 我的要求只做启发作用，你不能完全按照我的要求来，你应该要充分考虑需求是否合理，充分考虑使用逻辑来覆盖更多的
  使用场景，充分考虑需求是否可以拆分，充分考虑需求是否可以合并，充分考虑需求是否可以优化，充分考虑需求是否可
  以简化，充分考虑需求是否可以重构，充分考虑需求是否可以重用，充分考虑需求是否可以重构，充分考虑需求是否可以重用。
- 我的模型使用偏好：Claude-4-sonnet

### 测试驱动开发：
- ⚠️测试用例就是包青天，是权威标准，**你也是资深测试工程师，优先要保证测试用例的合理合规合法！测试用例定义了正确的业务逻辑和预期行为！**
- ⚠️**测试驱动开发**，先写测试用例，再写代码，形成坚固质量保障体系。

---

## 🟡 重要规则（建议遵循）

### 行动规范：
- 在开始工作前，应该明确自己的思路，明确任务主线和支线，支线任务完成后，回到主线任务，避免支线任务过度深入，而导致忽略了主线任务
- 在开始工作前，先阅读docs/README.md，了解项目概览、项目结构、项目依赖、项目配置、项目运行、项目测试、项目部署、项目文档。
- 在开始工作前，先阅读docs/GUIDE.md，了解新功能指南。
- 在开始工作前，先阅读docs/TODO.md，了解待办事项，包括待办、进行中、已完成。
- 在开始工作前，先阅读docs/FAQ.md，了解常见问题与解决方案，包括问题、解决方案、所属业务或模块。
- 在开始工作前，先阅读docs/API.md，了解API 接口文档，包括请求参数、响应参数、请求示例、响应示例、所属业务或模块。
- 在开始工作前，先阅读docs/CHANGELOG.md，了解更新日志，包括版本号、更新内容、所属业务或模块。
- 在开始工作前，先阅读docs/DOCUMENTATION_STANDARDS.md，了解文档书写规范。
- 在开始工作前，先阐述你的思路，并给出你的行动计划，得到我的认可后，再开始工作，除非我授权你无需询问我的意见。
- 开始工作后，频繁使用git进行版本控制，避免过多未提交更改，导致代码丢失。

### 开发与变更规范：
- 针对提出的新需求，你应该要充分考虑需求是否合理，充分考虑使用逻辑来覆盖更多的使用场景。
- 如果要修改数据库设计，先做好数据库备份，按照日期格式后缀备份。
- 以不影响已实现功能为前提，遵循小步迭代与最小化变更原则；必要时采用增量提交和特性分支。
- 变更前先理解现有代码与依赖，避免盲目试错式改动
- 涉及导入新的依赖包，及时更新到requirements.txt
- 开发或者变更完成，应该完善或修改测试用例，应该自主运行测试体系，比如单元测试和回归测试，确保功能正常，
  并且不影响原有功能，再给我反馈

### 测试规范：
- 测试用例的创建要坚持正确的业务逻辑和预期行为，不受已有业务代码约束，秉持合理、全面、覆盖所有使用场景的原则，坚持测试驱动开发。
- 创建测试用例时，假设没有明确的产品设计文档可供参考，那么你就是资深产品经理的角色，你应该自我思考，充分考虑使用场景，
  设置合理测试用例与期望，明确该功能的方向，提供该功能的脚手架，并提供功能的测试用例。
- 测试用例应该要覆盖**前端、后端、数据库**所有功能，并且要覆盖所有使用场景。
- 测试不通过时，应该反思是测试合理还是业务合理，如果测试不合理，应该修改测试用例，如果业务不合理，应该修改业务逻辑。
- 利用数据工厂，整理测试数据，并保存到tests/data/ 目录相应子目录中
- 修复 Bug 或新增功能必须配套单元测试与集成测试，遵循"修复 → 测试 → 验证"的流程。
- 测试用例编写要考虑可复用性，不要重复造轮子，不要重复造轮子，不要重复造轮子。
- 新增的测试用例要符合pytest的测试用例规范，应该自动嵌入测试体系，比如可以通过测试标记自动识别，通过目录结构自动发现或通过配置文件管理，跑一键测试可以自动执行该测试用例。
- 所有测试用例放入 tests/ 目录相应子目录中，测试执行后需保留测试用例，不能删除，除非测试用例已经失效。
- 开发或者完成重要功能变更，应该执行**一键测试**，确保功能正常，并且不影响原有功能。
- 执行一键测试前，遇到401报错，请先检查是否登录，如果未登录，请先登录。

### Debug规范：
- 排查过程中，应该先阅读docs/FAQ.md，了解常见问题与解决方案，包括问题、解决方案、所属业务或模块。
- bug修复之后要举一反三，思考是否存在其他类似问题，并给出解决方案，因为问题往往是系统性的，不是孤立的。
- 排查过程中应充分了解现有逻辑、数据库等实际数据来证明你的假设，而不是拍脑袋式尝试。
- 先建立明确的排查步骤与目标，逐步验证假设；补充必要日志以支撑定位；避免拍脑袋式尝试。
- debug过程中尽量别动原有正常逻辑代码，如果改动了之后还是无法定位问题，应该恢复原来代码并从另一个角度排查，
  避免引入新的问题。
- 每次修复Bug，需要根据bug所属业务或模块在docs/FAQ.md对应的目录中记录问题与最终解决方案，沉淀经验。
- 修复完成时，应该自主执行测试用例，以及回归测试，确保没有问题后，再给我反馈
- 修复完成时，应反思为什么没有测试出来，测试用例是否有遗漏，是否需要补充测试用例。

---

## 🟢 推荐规则（可选遵循）

### 文档定义：
- docs/README.md：项目概览，包括项目简介、项目结构、项目依赖、项目配置、项目运行、项目测试、项目部署、项目文档
- docs/GUIDE.md：新功能指南
- docs/TODO.md：待办事项，包括待办、进行中、已完成
- docs/FAQ.md：常见问题与解决方案，包括问题、解决方案、所属业务或模块
- docs/API.md：API 接口文档，包括请求参数、响应参数、请求示例、响应示例、所属业务或模块
- docs/CHANGELOG.md：更新日志，包括版本号、更新内容、所属业务或模块
- docs/DOCUMENTATION_STANDARDS.md：文档书写规范
- docs/KNOWLEDGE_BASE.md：知识库，包括知识、所属业务或模块
- docs/TESTING_STANDARDS.md：测试规范文档
- docs/TESTING_QUICK_START.md：测试快速开始文档

### 文档修改&新增规范：
- 若已有类似条目，请修改原条目，而并非新增条目
- 新功能指南更新至 docs/GUIDE.md；新功能涉及的技术概念更新到docs/KNOWLEDGE_BASE.md
- 新的待办整理到 docs/TODO.md；
- 已完成的待办及时更新状态到docs/TODO.md；
- 不随意新增新的文档，可以以新增条目的方式尽可能归纳到现有文档体系中。
- Markdown 使用：仅在必要处使用；文件/目录/函数/类名用反引号格式化；代码片段使用合适语言标注的代码块；
  避免整段全文包裹在同一代码块。
- 一次性的测试文件，应该在开发或debug完成之后归纳到tests/ 目录相应子目录中

### 终端命令规范（Windows 环境）：
- 使用绝对路径执行脚本或切换目录。
- 尽量避免使用无法交互的命令终端（例如 python 交互式 shell）；为可能交互的命令添加非交互参数。
- 命令示例默认以 Git Bash 语法给出；优先使用路径：C:\\LAYNESOFTWARE\\Git\\bin\\bash.exe。

### 日志规范：
- 日志要辅助问题的排查，重要的功能一定要记录日志。
- 日志文件路径：logs/ 目录下，按照日期格式后缀保存。
- 程序中应该要设置日志级别，并根据日志级别保存到不同文件中。
- 日志文件中应该要记录请求参数、响应参数、请求示例、响应示例、所属业务或模块。
- 日志文件中应该要记录请求时间、响应时间、请求耗时。
- debug过程可以根据日志文件来排查问题。

### 目录边界与审慎变更：
- 允许变更：测试代码、与当前任务直接相关的配置。
- 谨慎变更：原有业务代码，部署脚本、CI/CD 配置、K8s 清单等基础设施文件；如需修改，先评估影响并补充相应测试与回滚方案。

### 终端与服务管理：
- 不自动启动前端服务；如需启动，由开发者手动控制本地进程。

### 提交信息规范：
- 使用清晰的提交类型前缀（如 feat/fix/docs/test/chore/refactor）。
- 提交信息简要概述变更目的与影响，必要时附带范围说明。

### 回答期望：
- 遵循本规则生成建议、代码与命令；在存在多种可选方案时，优先选择影响面小、风险低且易于回滚的方案。

---

## 📋 工作检查清单

### 工作前检查
- [ ] 阅读了相关项目文档（README.md, GUIDE.md, TODO.md, FAQ.md, API.md, CHANGELOG.md, DOCUMENTATION_STANDARDS.md）
- [ ] 明确了任务主线和支线
- [ ] 制定了行动计划
- [ ] 确认了测试策略
- [ ] 阐述了思路并得到认可（除非授权无需询问）

### 工作后检查
- [ ] 更新了相关文档
- [ ] 编写了测试用例（测试驱动开发）
- [ ] 执行了回归测试
- [ ] 提交了代码变更（频繁使用git）
- [ ] 记录了问题和解决方案到docs/FAQ.md
- [ ] 反思了测试用例是否有遗漏

---

## 📝 示例参考

### 测试驱动开发示例
```python
# 1. 先写测试用例定义期望行为
def test_user_registration():
    user_data = {"username": "test", "email": "test@example.com"}
    result = register_user(user_data)
    assert result.success == True
    assert result.user.username == "test"

# 2. 运行测试确认失败
# 3. 编写最小代码使测试通过
# 4. 重构优化代码
```

### 文档更新示例
```markdown
## 新功能：用户注册
- 更新 docs/GUIDE.md：添加注册功能使用指南
- 更新 docs/API.md：添加注册接口文档
- 更新 docs/TODO.md：标记注册功能为已完成
- 更新 docs/FAQ.md：记录注册相关常见问题
- 更新 docs/KNOWLEDGE_BASE.md：添加相关技术概念
```

## 流程设计
### 新功能开发流程（别名：alpha流程）

#### 第一阶段：需求分析与规划（自动化）
- [ ] **智能需求分析**
  - 自动分析用户需求，识别核心功能和扩展功能
  - 自动判断功能复杂度（简单/中等/复杂）
  - 自动识别功能间的依赖关系
  - 自动生成功能拆分方案（MVP + 增强版本）

- [ ] **技术方案自动生成**
  - 自动分析需要改动的前端、后端、数据库组件
  - 自动生成技术实现方案
  - 自动评估开发风险和回滚方案
  - 自动生成开发时间估算

- [ ] **测试策略自动制定**
  - 自动生成测试用例设计
  - 自动识别测试覆盖范围
  - 自动生成测试数据需求
  - 自动制定回归测试策略

#### 第二阶段：MVP开发（自动化）
- [ ] **最小可行产品开发**
  - 自动编写核心功能测试用例
  - 自动实现最小功能代码
  - 自动执行单元测试和集成测试
  - 自动修复测试失败问题

- [ ] **基础功能验证**
  - 自动执行回归测试确保无破坏性变更
  - 自动生成功能演示数据
  - 自动验证核心业务流程
  - 自动提交MVP版本代码

#### 第三阶段：功能增强（增量式）
- [ ] **渐进式功能完善**
  - 自动识别功能增强点
  - 自动实现增强功能
  - 自动编写增强功能测试
  - 自动验证增强功能正确性

- [ ] **用户体验优化**
  - 自动优化用户界面交互
  - 自动添加错误处理和边界情况
  - 自动优化性能和响应速度
  - 自动添加用户反馈机制

#### 第四阶段：质量保障（自动化）
- [ ] **全面测试执行**
  - 自动执行一键测试
  - 自动执行性能测试
  - 自动执行安全测试
  - 自动生成测试报告

- [ ] **文档自动更新**
  - 自动更新API文档
  - 自动更新用户指南
  - 自动更新技术文档
  - 自动更新变更日志

#### 第五阶段：部署上线（自动化）
- [ ] **代码质量检查**
  - 自动执行代码规范检查
  - 自动执行静态代码分析
  - 自动检查依赖安全性
  - 自动生成代码质量报告

- [ ] **部署准备**
  - 自动更新配置文件
  - 自动更新依赖包
  - 自动生成部署脚本
  - 自动准备回滚方案

#### 第六阶段：监控与维护（自动化）
- [ ] **功能监控**
  - 自动监控功能使用情况
  - 自动收集用户反馈
  - 自动识别潜在问题
  - 自动生成优化建议

- [ ] **持续改进**
  - 自动分析性能瓶颈
  - 自动识别功能改进点
  - 自动生成下一版本计划
  - 自动更新TODO清单

### 自动化执行规则
1. **无需人工干预的场景**：
   - 测试用例编写和执行
   - 代码规范检查和修复
   - 文档自动更新
   - 基础功能验证
   - 回归测试执行

2. **需要用户确认的场景**（会发出声音提示）：
   - 重大架构变更
   - 数据库结构修改
   - 第三方依赖引入
   - 安全相关配置
   - 生产环境部署

3. **智能决策机制**：
   - 自动选择最优技术方案
   - 自动判断功能优先级
   - 自动识别测试失败原因
   - 自动生成修复方案
   - 自动评估代码质量

### 声音提示系统
1. **通知类型**：
   - 🔔 **一般通知**：信息提示，使用 `beep.wav`
   - ✅ **确认通知**：需要确认操作，使用 `correct.wav`
   - ⚠️ **警告通知**：需要授权操作，使用 `key-default.wav`
   - 🚨 **紧急通知**：重要操作，连续播放多次

2. **触发场景**：
   - 需求分析完成时
   - 需要用户确认时
   - 需要用户授权时
   - 重大变更时
   - 测试完成时
   - 部署准备时
   - 错误发生时

3. **声音控制**：
   - 可通过 `notificationManager.toggleSound()` 启用/禁用
   - 可通过 `notificationManager.stopAll()` 停止所有声音
   - 支持查看通知历史记录

### 增量式开发策略
1. **MVP优先**：先实现核心功能，再逐步增强
2. **测试驱动**：每个功能都有对应测试用例
3. **持续集成**：每次代码变更都自动测试
4. **渐进增强**：功能按优先级逐步完善
5. **快速迭代**：小步快跑，快速验证

### 可持续开发保障
1. **自动化测试**：确保代码质量
2. **自动化部署**：减少人工错误
3. **自动化监控**：及时发现问题
4. **自动化文档**：保持文档同步
5. **自动化回滚**：快速恢复问题